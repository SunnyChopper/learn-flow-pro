// System
import { DataSource } from "typeorm";
import { z } from "zod";

// Database
import { createDataSource } from "src/utils/database";
import { ArticleCache } from "src/entity/ArticleCache";
import { Article } from "src/entity/Article";
import { Goal } from "src/entity/Goal";
import { Note } from "src/entity/Note";

// Langchain
import { StructuredOutputParser } from "langchain/output_parsers";
import { ChatPromptTemplate } from "langchain/dist/prompts";

// Services
import PromptsService, { SUMMARIZE_ARTICLE, NOTES_FOR_ARTICLE } from '/opt/services/PromptsService';
import BaseLLMService from "/opt/services/llms/BaseLLMService";
import MediumService from "/opt/services/MediumService";
import GoalsService from "/opt/services/GoalsService";
import NotesService from "/opt/services/NotesService";

class ArticleService extends BaseLLMService {
    constructor(key: string, service: string = "openai", model: string = "gpt-3.5-turbo", mode: string = "creative") {
        super(key, service, model, mode);
    }

    private async initialize(source: DataSource): Promise<void> {
        if (!source.isInitialized) {
            await source.initialize();
        }
    }

    private async destroy(source: DataSource): Promise<void> {
        if (source.isInitialized) {
            await source.destroy();
        }
    }

    private async appendArticleCacheToArticles(articles: Article[], dataSource?: DataSource): Promise<Article[]> {
        let enhancedArticles: Article[] = [];
        for (let i = 0; i < articles.length; i++) {
            enhancedArticles.push(await this.appendArticleCacheToArticle(articles[i], dataSource));
        }
        return enhancedArticles;
    }

    private async appendArticleCacheToArticle(article: Article, dataSource?: DataSource): Promise<Article> {
        const AppDataSource = dataSource ? dataSource : await createDataSource();
        await this.initialize(AppDataSource);
        const articleCacheRepository = AppDataSource.getRepository(ArticleCache);
        const articleCache: ArticleCache | null = await articleCacheRepository.findOneBy({
            articleMediumId: MediumService.getMediumArticleId(article.url)
        });

        if (articleCache) { article.summary = articleCache.summary; }
        await this.destroy(AppDataSource);

        return article;
    }

    public async getArticlesForUser(userId: string, sort?: boolean): Promise<Article[]> {
        const AppDataSource = await createDataSource();
        await this.initialize(AppDataSource);
        const articleRepository = AppDataSource.getRepository(Article);
        
        let articles: Article[] = await articleRepository.findBy({ userId: userId });
        if (sort === true) {
            articles = articles.sort((a: Article, b: Article) => {
                if (a.createdAt === undefined || b.createdAt === undefined) {
                    return 0;
                }

                if (a.createdAt > b.createdAt) {
                    return -1;
                } else if (a.createdAt < b.createdAt) {
                    return 1;
                } else {
                    return 0;
                }
            });
        }

        let enhancedArticles: Article[] = await this.appendArticleCacheToArticles(articles);

        await this.destroy(AppDataSource);
        return enhancedArticles;
    }

    public async getArticlesForSession(sessionId: number): Promise<Article[]> {
        const AppDataSource = await createDataSource();
        await this.initialize(AppDataSource);
        const articleRepository = AppDataSource.getRepository(Article);
        const articles: Article[] = await articleRepository.findBy({ sessionId: sessionId });
        let enhancedArticles: Article[] = await this.appendArticleCacheToArticles(articles, AppDataSource);
        await this.destroy(AppDataSource);
        return enhancedArticles;
    }

    public async getArticle(userId: string, articleId: number): Promise<Article> {
        const AppDataSource = await createDataSource();
        await this.initialize(AppDataSource);
        const articleRepository = AppDataSource.getRepository(Article);
        const article: Article | null = await articleRepository.findOneBy({ userId: userId, id: articleId });
        if (!article) {
            throw new Error('Article not found.');
        }
        await this.destroy(AppDataSource);
        return article;
    }

    public async createArticle(article: Article): Promise<Article> {
        const AppDataSource = await createDataSource();
        await this.initialize(AppDataSource);
        const articleRepository = AppDataSource.getRepository(Article);

        let savedArticle: Article | null = null;
        try {
            savedArticle = await articleRepository.save(article);
        } catch (error) {
            console.log("Error creating article: ", error);
        } finally {
            await this.destroy(AppDataSource);
            if (!savedArticle) {
                throw new Error('Article not found.');
            }
            return savedArticle;
        }
    }

    public async generateSummaryForArticle(userId: string, articleId: number, useCache: boolean = false): Promise<string> {
        let article: Article | null = null;
        try {
            article = await this.getArticle(userId, articleId);
        } catch (error) {
            console.log("Error getting article: ", error);
            throw error;
        }

        if (useCache === true) {
            const AppDataSource = await createDataSource();
            await this.initialize(AppDataSource);
            const articleCacheRepository = AppDataSource.getRepository(ArticleCache);
            const articleCache: ArticleCache | null = await articleCacheRepository.findOneBy({
                articleId: article.id || -1
            });
            console.log("ðŸš€ ~ file: ArticleService.ts:140 ~ ArticleService ~ generateSummaryForArticle ~ articleCache:", articleCache);

            if (articleCache && articleCache.summary) {
                this.destroy(AppDataSource);
                return articleCache.summary;
            }
        }
        
        let chatPrompt: ChatPromptTemplate | null = null;
        try {
            chatPrompt = await PromptsService.loadChatPrompt(SUMMARIZE_ARTICLE);
        } catch (error) {
            console.log("Error loading chat prompt: ", error);
            throw error;
        }

        if (!chatPrompt) {
            console.log("Chat prompt not found.");
            throw new Error("Chat prompt not found.");
        }

        const mediumService: MediumService = new MediumService();

        let markdown: string;
        try {
            markdown = await mediumService.getMarkdownForArticle(article);
        } catch (error) {
            console.log("Error getting markdown for article: ", error);
            throw error;
        }

        const outputParser = StructuredOutputParser.fromZodSchema(z.object({
            summary: z.string().describe('The summary of the article.')
        }).describe('The output of the summarize article chat prompt.'));

        let inputs: { [key: string]: string } = {
            title: article.title,
            content: markdown
        };

        let response: { summary: string } | null = null;

        try {
            response = await this.llmService.generateResponse(chatPrompt, inputs, outputParser) as { summary: string };
        } catch (error) {
            console.log("Error generating response: ", error);
            throw error;
        } finally {
            if (!response) {
                throw new Error("Response not found.");
            }

            // Save the summary to the database in the `ArticleCache` entity
            const AppDataSource = await createDataSource();
            await this.initialize(AppDataSource);
            const articleCacheRepository = AppDataSource.getRepository(ArticleCache);
            const articleCache: ArticleCache | null = await articleCacheRepository.findOneBy({
                articleId: article.id || -2
            });
            
            if (articleCache) {
                articleCache.summary = response.summary;
                await articleCacheRepository.save(articleCache);
            } else {
                const articleCacheToCreate: ArticleCache = new ArticleCache();
                articleCacheToCreate.articleId = article.id || -1;
                articleCacheToCreate.articleMediumId = MediumService.getMediumArticleId(article.url);
                articleCacheToCreate.markdown = markdown;
                articleCacheToCreate.summary = response.summary;
                await articleCacheRepository.save(articleCacheToCreate);
            }

            await this.destroy(AppDataSource);
            return response.summary;
        }
    }

    public async generateNotesForArticleMarkdown(userId: string, articleId: number): Promise<string> {
        let chatPrompt: ChatPromptTemplate | null = null;
        try {
            chatPrompt = await PromptsService.loadChatPrompt(NOTES_FOR_ARTICLE);
        } catch (error) {
            console.log("Error loading chat prompt: ", error);
            throw error;
        }

        if (!chatPrompt) {
            console.log("Chat prompt not found.");
            throw new Error("Chat prompt not found.");
        }

        // 2. Get the goals based on the current user
        const goalsService: GoalsService = new GoalsService();
        const goals: Goal[] = await goalsService.getGoalsForUser(userId);

        // 3. Get the articles (and their content) for the session
        const article: Article = await this.getArticle(userId, articleId);
        const mediumService: MediumService = new MediumService();
        const markdown: string = await mediumService.getMarkdownForArticle(article);

        const outputParser = StructuredOutputParser.fromZodSchema(z.object({
            notes: z.array(z.object({
                title: z.string().describe('The title of the note.'),
                content: z.string().describe('The content of the note.')
            }).describe('A note for the article.')).describe('The list of notes for the article.')
        }).describe('The output of the notes for article chat prompt.'));

        let inputs: { [key: string]: string } = {
            title: article.title,
            content: markdown,
            goals: goals.map((goal: Goal) => `- ${goal.goal}`).join("\n")
        };

        let response: { notes: { title: string, content: string }[] } | null = null;
        try {
            response = await this.llmService.generateResponse(chatPrompt, inputs, outputParser) as { notes: { title: string, content: string }[] };
        } catch (error) {
            console.log("Error generating response: ", error);
            throw error;
        }

        const noteString: string = response.notes.map((note: { title: string, content: string }) => `### ${note.title}\n${note.content}`).join("\n\n---\n\n");

        const notesService: NotesService = new NotesService();
        const noteToCreate: Note = new Note();
        noteToCreate.articleId = articleId;
        noteToCreate.note = noteString;
        await notesService.createNoteForArticle(noteToCreate);
        return noteString;
    }

}

export default ArticleService;