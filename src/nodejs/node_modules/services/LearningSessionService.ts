// System
import { z } from "zod";

// Database
import { SessionArticleSort } from "src/entity/SessionArticleSort";
import { LearningSession } from "src/entity/LearningSession";
import { createDataSource } from "src/utils/database";

// Langchain
import { StructuredOutputParser } from "langchain/output_parsers";
import { ChatPromptTemplate } from "langchain/prompts";

// Services
import PromptsService, { SORT_ARTICLES } from "/opt/services/PromptsService";
import BaseLLMService from "/opt/services/llms/BaseLLMService";
import ArticleService from "/opt/services/ArticleService";
import MediumService from "/opt/services/MediumService";
import GoalsService from "/opt/services/GoalsService";

// Entities
import { Article } from "src/entity/Article";
import { Goal } from "src/entity/Goal";

// Contracts
import { SortedArticles, SortedArticle } from "src/contracts/SortArticles";

class LearningSessionService extends BaseLLMService {
    private key: string;
    private service: string;
    private model: string;
    private mode: string;

    constructor(key: string, service: string = "openai", model: string = "gpt-3.5-turbo", mode: string = "creative") {
        super(key, service, model, mode);
        
        this.key = key;
        this.service = service;
        this.model = model;
        this.mode = mode;
    }

    private async getSortingTemplate(): Promise<ChatPromptTemplate> {
        try {
            return await PromptsService.loadChatPrompt(SORT_ARTICLES);
        } catch (error) {
            console.log("Error loading chat template: ", error);
            throw error;
        }
    }

    private getOutputParserForSortedArticles(): StructuredOutputParser<z.infer<z.ZodAny>> {
        return StructuredOutputParser.fromZodSchema(z.object({
            sortedArticles: z.array(z.object({
                id: z.number().describe('The ID of the article.'),
                title: z.string().describe('The title of the article.'),
                sort: z.number().describe('The sort order of the article with respect to the user\'s learning goals.'),
                reason: z.string().describe('The reason for the sort order.'),
                informationFlow: z.string().describe('The information flow of the article.')
            })).describe('The list of articles sorted by relevance to the user\'s learning goals.')
        }).describe('The output of the sort articles chat prompt.'));
    }

    private getInputsForSortingArticles(articles: Article[], goals: Goal[]): { [key: string]: string } {
        return {
            goals: goals.map((goal: Goal) => `- ${goal.goal}`).join("\n"),
            articles: articles.map((article: Article, index: number) => {
                // Numbered list of title and summary
                const summary: string = article.summary?.slice(0, 150) || '';
                const title: string = article.title;
                return `${index + 1}. ${title} (ID: ${article.id})\nSummary: ${summary}`;
            }).join("\n\n---\n\n")
        }   
    }

    public async sortArticlesByRelevance(userId: string, sessionId: number, articles: Article[]): Promise<SortedArticles> {
        console.time("sortArticlesByRelevance");
        // 1. Get the prompt template for the LLM
        let chatTemplate: ChatPromptTemplate = await this.getSortingTemplate();

        const articlesService: ArticleService = new ArticleService(this.key, this.service, this.model, this.mode);
        
        const goalsService: GoalsService = new GoalsService();
        const goals: Goal[] = await goalsService.getGoalsForUser(userId);

        let articlesContent: { [key: number]: { title: string, content: string }} = {};
        let summaries: { [key: number]: string } = {};
        
        const articlesWithoutSummaries: number = articles.filter((article: Article) => article.summary === null || article.summary === undefined || article.summary.length === 0).length;
        if (articlesWithoutSummaries > 0) {
            const mediumService: MediumService = new MediumService();
            for (const article of articles) {
                if (!article.url || !article.id) {
                    console.error('Skipping article without URL or ID: ', article);
                    continue;
                }
    
                if (article.summary !== null && article.summary !== undefined && article.summary.length > 0) {
                    articlesContent[article.id] = { title: article.title, content: '' };
                    summaries[article.id] = article.summary;
                    continue;
                }
    
                // a. Get the markdown for the article
                const markdown: string = await mediumService.getMarkdownForArticle(article);
                articlesContent[article.id] = {
                    title: article.title,
                    content: markdown
                };
    
                // b. Generate or get from cache the summary for the article
                try {
                    const summary: string = await articlesService.generateSummaryForArticle(userId, article.id, true);
                    summaries[article.id] = summary;
                } catch (error) {
                    console.log("Error generating summary for article: ", error);
                    throw error;
                }
            }
        } else {
            articlesContent = articles.map((article: Article) => {
                return {
                    title: article.title,
                    content: ''
                }
            });
            summaries = articles.map((article: Article) => {
                return article.summary as string;
            });
        }
        
        const inputs: { [key: string]: string } = this.getInputsForSortingArticles(articles, goals);
        
        const outputParser = this.getOutputParserForSortedArticles();

        try {
            console.timeEnd("sortArticlesByRelevance");
            const response = await this.llmService.generateResponse(chatTemplate, inputs, outputParser) as SortedArticles;
            console.log("ðŸš€ ~ file: LearningSessionService.ts:101 ~ LearningSessionService ~ sortArticlesByRelevance ~ response:", response)
            
            const newArticleSorts: SessionArticleSort[] = response.sortedArticles.map((sortedArticle: SortedArticle) => {
                let articleId: number = articles.find((article: Article) => article.title === sortedArticle.title)?.id as number;
                if (!articleId) {
                    // Attempt to find by ID
                    articleId = articles.find((article: Article) => article.id === sortedArticle.id)?.id as number;
                }

                return {
                    sessionId: sessionId,
                    articleId: articleId,
                    sort: sortedArticle.sort,
                    reason: sortedArticle.reason,
                    informationFlow: sortedArticle.informationFlow
                }
            });
            const AppDataSource = await createDataSource();
            if (!AppDataSource.isInitialized) { await AppDataSource.initialize(); }
            const articleSortRepository = AppDataSource.getRepository(SessionArticleSort);
            await articleSortRepository.save(newArticleSorts);
            if (AppDataSource.isInitialized) { await AppDataSource.destroy(); }
            return response;
        } catch (error) {
            console.log("Error generating response: ", error);
            throw error;
        }
    }

    public async getSession(userId: string, sessionId: number): Promise<LearningSession> {
        const AppDataSource = await createDataSource();
        if (!AppDataSource.isInitialized) { await AppDataSource.initialize(); }
        const sessionRepository = AppDataSource.getRepository(LearningSession);
        const session: LearningSession | null = await sessionRepository.findOneBy({ userId: userId, id: sessionId });
        if (!session) {
            throw new Error('Session not found.');
        }
        if (AppDataSource.isInitialized) { await AppDataSource.destroy(); }
        return session;
    }

    public async getSessions(userId: string): Promise<LearningSession[]> {
        const AppDataSource = await createDataSource();
        if (!AppDataSource.isInitialized) { await AppDataSource.initialize(); }
        const sessionRepository = AppDataSource.getRepository(LearningSession);
        const sessions: LearningSession[] = await sessionRepository.find({
            where: { userId: userId },
            order: { createdAt: 'DESC' } // add order parameter to sort by createdAt in descending order
        });
        if (AppDataSource.isInitialized) { await AppDataSource.destroy(); }
        return sessions;
    }

    public async createSession(session: LearningSession): Promise<LearningSession> {
        const AppDataSource = await createDataSource();
        if (!AppDataSource.isInitialized) { await AppDataSource.initialize(); }
        const sessionRepository = AppDataSource.getRepository(LearningSession);
        try {
            const newSession = await sessionRepository.save(session);
            if (AppDataSource.isInitialized) { await AppDataSource.destroy(); }
            return newSession;
        } catch (error) {
            console.log("Error creating session: ", error);
            if (AppDataSource.isInitialized) { await AppDataSource.destroy(); }
            return session;
        };
    }

}

export default LearningSessionService;