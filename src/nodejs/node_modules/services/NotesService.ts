import { DataSource } from "typeorm";

// Database
import { createDataSource } from "src/utils/database";
import { Article } from "src/entity/Article";
import { Note } from "src/entity/Note";

class NotesService {

    private async establishConnection(source: DataSource): Promise<void> {
        if (source.isInitialized === false) {
            await source.initialize();
        }
    }

    private async closeConnection(source: DataSource): Promise<void> {
        if (source.isInitialized === true) {
            await source.destroy();
        }
    }
    
    public async getNotesForArticle(articleId: number): Promise<Note[]> {
        const AppDataSource = await createDataSource();
        await this.establishConnection(AppDataSource);
        const noteRepository = AppDataSource.getRepository(Note);
        const notes: Note[] = await noteRepository.findBy({ articleId: articleId });
        await this.closeConnection(AppDataSource);
        return notes;
    }

    public async getNotesForArticles(articleIds: number[]): Promise<Note[]> {
        if (articleIds.length === 0) {
            return [];
        }
        const AppDataSource = await createDataSource();
        await this.establishConnection(AppDataSource);
        const noteRepository = AppDataSource.getRepository(Note);
        const notes: any = await noteRepository.createQueryBuilder().select()
            .where(`articleId IN (${articleIds.join(',')})`).execute();
        await this.closeConnection(AppDataSource);
        
        // Remove the "Note_" prefix from the keys
        return notes.map((note: any) => {
            const newNote: Note = {
                id: note.Note_id,
                articleId: note.Note_articleId,
                note: note.Note_note,
                createdAt: note.Note_createdAt
            };
            return newNote;
        });
    }

    public async getNotesForUser(userId: string): Promise<Note[]> {
        const AppDataSource = await createDataSource();
        await this.establishConnection(AppDataSource);
        const articleRepository = AppDataSource.getRepository(Article);
        const articles: Article[] = await articleRepository.findBy({ userId: userId });
        const noteRepository = AppDataSource.getRepository(Note);
        if (articles.length === 0) {
            return [];
        }

        const notes: any[] = await noteRepository.createQueryBuilder().select()
            .where(`articleId IN (${articles.map(article => article.id).join(',')})`).execute();
        await this.closeConnection(AppDataSource);
        // Remove the "Note_" prefix from the keys
        return notes.map(note => {
            const newNote: Note = {
                id: note.Note_id,
                articleId: note.Note_articleId,
                note: note.Note_note,
                createdAt: note.Note_createdAt
            };
            return newNote;
        });
    }

    public async getNote(noteId: number): Promise<Note> {
        const AppDataSource = await createDataSource();
        await this.establishConnection(AppDataSource);
        const noteRepository = AppDataSource.getRepository(Note);
        const note: Note | null = await noteRepository.findOneBy({ id: noteId });
        if (!note) { throw new Error('Note not found.'); }
        await this.closeConnection(AppDataSource);
        return note;
    }

    public async createNoteForArticle(note: Note): Promise<Note> {
        const AppDataSource = await createDataSource();
        await this.establishConnection(AppDataSource);
        const noteRepository = AppDataSource.getRepository(Note);
        try {
            const newNote = await noteRepository.save(note);
            await this.closeConnection(AppDataSource);
            return newNote;
        } catch (error) {
            console.log("Error creating note: ", error);
            await this.closeConnection(AppDataSource);
            return note;
        };
    }

}

export default NotesService;