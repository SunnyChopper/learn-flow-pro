// System
import { DataSource } from "typeorm";
import { Buffer } from "buffer";
import { z } from "zod";

// Langchain
import { StructuredOutputParser } from "langchain/output_parsers";
import { ChatPromptTemplate } from "langchain/prompts";

// Services
import PromptsService, { RECOMMEND_TOPICS } from "/opt/services/PromptsService";
import BaseLLMService from "/opt/services/llms/BaseLLMService";
import ArticleService from "/opt/services/ArticleService";
import GoalsService from "/opt/services/GoalsService";

// Entities
import { Recommendation } from "src/entity/Recommendation";
import { createDataSource } from "src/utils/database";
import { Article } from "src/entity/Article";
import { Goal } from "src/entity/Goal";

// Constants
export const MAX_ARTICLES_FOR_RECOMMENDATIONS: number = 20;
export const TOPIC_SEPARATOR: string = "\n\n---\n\n";

class RecommendationService extends BaseLLMService {
    private key: string;
    private service: string;
    private model: string;
    private mode: string;

    constructor(key: string, service: string = "openai", model: string = "gpt-3.5-turbo", mode: string = "creative") {
        super(key, service, model, mode);

        this.key = key;
        this.service = service;
        this.model = model;
        this.mode = mode;
    }

    private async establishConnection(source: DataSource): Promise<void> {
        if (source.isInitialized === false) {
            await source.initialize();
        }
    }

    private async closeConnection(source: DataSource): Promise<void> {
        if (source.isInitialized === true) {
            await source.destroy();
        }
    }

    public async generateTopicRecommendationsUsingArticles(userId: string): Promise<{ topics: string[] }> {
        // 1. Get the prompt template
        let chatPrompt: ChatPromptTemplate | null = null;
        try {
            chatPrompt = await PromptsService.loadChatPrompt(RECOMMEND_TOPICS);
        } catch (error) {
            console.log("Error loading chat prompt: ", error);
            throw error;
        }

        if (!chatPrompt) {
            console.log("Chat prompt not found.");
            throw new Error("Chat prompt not found.");
        }

        // 2. Get the user's goals
        const goalsService: GoalsService = new GoalsService();
        const goals: Goal[] = await goalsService.getGoalsForUser(userId);

        // 3. Get the articles that belong to the user
        const articleService: ArticleService = new ArticleService(this.key, this.service, this.model, this.mode);
        const sortedArticles: Article[] = await articleService.getArticlesForUser(userId, true);
        const articles: Article[] = sortedArticles.slice(0, MAX_ARTICLES_FOR_RECOMMENDATIONS);

        // 3b. Generate a hash of the string of all article titles.
        // This is used to prevent overcalling the API for the same articles.
        const articleHash: string = Buffer.from(articles.map((article: Article) => `- ${article.title}`).join("\n")).toString('base64');

        // 3c. Check to see if recommendation already exists
        const existingRecommendation: Recommendation | null = await this.readRecommendationByHash(articleHash);
        if (existingRecommendation) {
            return { topics: existingRecommendation.recommendation.split(TOPIC_SEPARATOR) };
        }

        // 4. Output parser
        const outputParser = StructuredOutputParser.fromZodSchema(z.object({
            topics: z.array(z.string().describe('A topic that was recommended.')).describe('The list of topics that were recommended.')
        }).describe('The output of the recommend topics chat prompt.'));

        // 5. Inputs for prompt template
        let inputs: { [key: string]: string } = {
            goals: goals.map((goal: Goal) => `- ${goal.goal}`).join("\n"),
            articles: articles.map((article: Article) => `- ${article.title}`).join("\n")
        };

        // 6. Generate response
        let response: { topics: string[] } | null = null;
        try {
            response = await this.llmService.generateResponse(chatPrompt, inputs, outputParser) as { topics: string[] };
        } catch (error) {
            console.log("Error generating response: ", error);
            throw error;
        }

        // 7. Save the recommendations
        const recommendation: Recommendation = new Recommendation();
        recommendation.userId = userId;
        recommendation.recommendationType = 'topics';
        recommendation.recommendation = response.topics.join(TOPIC_SEPARATOR);
        recommendation.articleHash = articleHash;
        await this.createRecommendation(recommendation);

        return response;
    }

    public async createRecommendation(recommendation: Recommendation): Promise<Recommendation> {
        const AppDataSource = await createDataSource();
        await this.establishConnection(AppDataSource);
        const recommendationRepository = AppDataSource.getRepository(Recommendation);
        try {
            const newRecommendation = await recommendationRepository.save(recommendation);
            await this.closeConnection(AppDataSource);
            return newRecommendation;
        } catch (error) {
            console.log("Error creating recommendation: ", error);
            await this.closeConnection(AppDataSource);
            return recommendation;
        };
    }

    public async readRecommendationByHash(articleHash: string): Promise<Recommendation | null> {
        const AppDataSource = await createDataSource();
        await this.establishConnection(AppDataSource);
        const recommendationRepository = AppDataSource.getRepository(Recommendation);
        const recommendation: Recommendation | null = await recommendationRepository.findOneBy({ articleHash: articleHash });
        await this.closeConnection(AppDataSource);
        return recommendation;
    }

    public async readRecommendationsForUser(userId: string): Promise<Recommendation[]> {
        const AppDataSource = await createDataSource();
        await this.establishConnection(AppDataSource);
        const recommendationRepository = AppDataSource.getRepository(Recommendation);
        const recommendations: Recommendation[] = await recommendationRepository.findBy({ userId: userId });
        await this.closeConnection(AppDataSource);
        return recommendations;
    }

}

export default RecommendationService;